import { Injectable, NgModule } from '@angular/core';
import { Router, RouterModule } from '@angular/router';
import { CommonModule } from '@angular/common';
import { HTTP_INTERCEPTORS } from '@angular/common/http';
import { BehaviorSubject } from 'rxjs/BehaviorSubject';
import { Headers, Http, HttpModule, Request, RequestMethod, RequestOptions, URLSearchParams } from '@angular/http';
import 'rxjs/add/operator/map';
import { Observable } from 'rxjs/Observable';

/**
 * Created by Mo3in on 5/29/2017.
 */
var AuthConfig = (function () {
    /**
     * @param {?=} config
     */
    function AuthConfig(config) {
        if (config === void 0) { config = {}; }
        for (var option in config)
            this[option] = config[option];
        for (var option in AUTH_CONFIG_DEFAULTS)
            this[option] = config[option] != null ? config[option] : AUTH_CONFIG_DEFAULTS[option];
    }
    return AuthConfig;
}());
var AUTH_CONFIG_DEFAULTS = {
    headerName: "Authorization",
    loginTokenName: "access_token",
    headerPrefix: "Bearer",
    noTokenScheme: false,
    noJwtError: false,
};

var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TokenError = (function (_super) {
    __extends(TokenError, _super);
    /**
     * @param {?} message
     */
    function TokenError(message) {
        var _this = _super.call(this, message) || this;
        _this.name = 'TokenError';
        return _this;
    }
    return TokenError;
}(Error));
var Token = (function () {
    /**
     * @param {?} token
     */
    function Token(token) {
        this.token = token;
        if (this.token != null && this.isExpired()) {
            token = null;
        }
    }
    /**
     * @param {?} str
     * @return {?}
     */
    Token.prototype.decodeBase64 = function (str) {
        var /** @type {?} */ output = str.replace(/-/g, '+').replace(/_/g, '/');
        switch (output.length % 4) {
            case 0: {
                break;
            }
            case 2: {
                output += '==';
                break;
            }
            case 3: {
                output += '=';
                break;
            }
            default: {
                throw new TokenError('Illegal base64url string!');
            }
        }
        return decodeURIComponent(escape(typeof window === 'undefined' ? atob(output) : window.atob(output)));
    };
    /**
     * @return {?}
     */
    Token.prototype.decodeToken = function () {
        var /** @type {?} */ parts = this.token.split('.');
        if (parts.length !== 3) {
            throw new TokenError('A JWT Token must have 3 parts!');
        }
        var /** @type {?} */ decoded = this.decodeBase64(parts[1]);
        if (!decoded) {
            throw new TokenError('Cannot decode the token!');
        }
        return JSON.parse(decoded);
    };
    /**
     * @return {?}
     */
    Token.prototype.getExpirationDate = function () {
        var /** @type {?} */ decoded = this.decodeToken();
        if (!decoded.hasOwnProperty('exp')) {
            return new Date();
        }
        var /** @type {?} */ date = new Date(0);
        date.setUTCSeconds(decoded.exp);
        return date;
    };
    /**
     * @param {?=} offsetSeconds
     * @return {?}
     */
    Token.prototype.isExpired = function (offsetSeconds) {
        if (offsetSeconds === void 0) { offsetSeconds = 0; }
        var /** @type {?} */ date = this.getExpirationDate();
        if (date.getSeconds() === new Date().getSeconds()) {
            return false;
        }
        return !(date.valueOf() > (new Date().valueOf() + (offsetSeconds * 1000)));
    };
    return Token;
}());

var TokenService = (function () {
    function TokenService() {
        this._token = new BehaviorSubject(new Token(localStorage.getItem('auth_token')));
    }
    /**
     * Get the current token.
     * @return {?}
     */
    TokenService.prototype.getToken = function () {
        var /** @type {?} */ token = this._token.getValue();
        return (token && token.token) ? token : null;
    };
    /**
     * Returns an stream of tokens.
     * @return {?}
     */
    TokenService.prototype.getTokenStream = function () {
        return this._token.asObservable();
    };
    /**
     * Update the current token.
     * @param {?} token
     * @return {?}
     */
    TokenService.prototype.setToken = function (token) {
        this._token.next(new Token(token));
        localStorage.setItem('auth_token', token);
    };
    /**
     * Remove the current token.
     * @return {?}
     */
    TokenService.prototype.removeToken = function () {
        this._token.next(null);
        localStorage.removeItem('auth_token');
    };
    return TokenService;
}());
TokenService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
TokenService.ctorParameters = function () { return []; };

var JwtHttpInterceptor = (function () {
    /**
     * @param {?} config
     * @param {?} _tokenService
     */
    function JwtHttpInterceptor(config, _tokenService) {
        this.config = config;
        this._tokenService = _tokenService;
        this.config = new AuthConfig(config);
    }
    /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    JwtHttpInterceptor.prototype.intercept = function (req, next) {
        var /** @type {?} */ token = this._tokenService.getToken();
        if (!token.isExpired())
            req = req.clone({ headers: req.headers.set(this.config.headerName, this.config.headerPrefix + " " + token.token) });
        return next.handle(req);
    };
    return JwtHttpInterceptor;
}());
JwtHttpInterceptor.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
JwtHttpInterceptor.ctorParameters = function () { return [
    { type: AuthConfig, },
    { type: TokenService, },
]; };

var Auth = (function () {
    /**
     * @param {?} _tokenService
     */
    function Auth(_tokenService) {
        this._tokenService = _tokenService;
    }
    /**
     * @return {?}
     */
    Auth.prototype.loggedIn = function () {
        var /** @type {?} */ token = this._tokenService.getToken();
        return token && token.token && !token.isExpired();
    };
    return Auth;
}());
Auth.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
Auth.ctorParameters = function () { return [
    { type: TokenService, },
]; };

var AuthenticationService = (function () {
    /**
     * @param {?} http
     * @param {?} authConfig
     * @param {?} _tokenService
     */
    function AuthenticationService(http, authConfig, _tokenService) {
        this.http = http;
        this.authConfig = authConfig;
        this._tokenService = _tokenService;
        this.authConfig = new AuthConfig(authConfig);
    }
    /**
     * @param {?} username
     * @param {?} password
     * @return {?}
     */
    AuthenticationService.prototype.login = function (username, password) {
        var _this = this;
        var /** @type {?} */ body = new URLSearchParams();
        var /** @type {?} */ loginParams = this.authConfig.loginParams;
        for (var /** @type {?} */ key in loginParams)
            body.set(key, loginParams[key]);
        body.set("username", username);
        body.set("password", password);
        var /** @type {?} */ headers = new Headers();
        headers.append('Content-Type', 'application/x-www-form-urlencoded');
        return this.http.post(this.authConfig.loginEndPoint, body, { headers: headers }).map(function (response) {
            var /** @type {?} */ token = response.json() && response.json()[_this.authConfig.loginTokenName];
            if (token) {
                _this._tokenService.setToken(token);
                return true;
            }
            else {
                return false;
            }
        });
    };
    /**
     * @param {?=} redirect
     * @return {?}
     */
    AuthenticationService.prototype.logout = function (redirect) {
        this._tokenService.removeToken();
        // if(redirect)
    };
    return AuthenticationService;
}());
AuthenticationService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
AuthenticationService.ctorParameters = function () { return [
    { type: Http, },
    { type: AuthConfig, },
    { type: TokenService, },
]; };

/**
 * Created by Mo3in on 5/29/2017.
 */
var LoggedOutAuth = (function () {
    /**
     * @param {?} _config
     * @param {?} _tokenService
     * @param {?} _router
     */
    function LoggedOutAuth(_config, _tokenService, _router) {
        this._config = _config;
        this._tokenService = _tokenService;
        this._router = _router;
    }
    /**
     * @return {?}
     */
    LoggedOutAuth.prototype.canActivate = function () {
        var /** @type {?} */ token = this._tokenService.getToken();
        if (token && token.token && !token.isExpired()) {
            var /** @type {?} */ redirectUrl = this._config.guards.loggedOutGuard.redirectUrl;
            if (redirectUrl)
                this._router.navigate([redirectUrl]);
            return false;
        }
        return true;
    };
    return LoggedOutAuth;
}());
LoggedOutAuth.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
LoggedOutAuth.ctorParameters = function () { return [
    { type: AuthConfig, },
    { type: TokenService, },
    { type: Router, },
]; };
var LoggedInAuth = (function () {
    /**
     * @param {?} _config
     * @param {?} _tokenService
     * @param {?} _router
     */
    function LoggedInAuth(_config, _tokenService, _router) {
        this._config = _config;
        this._tokenService = _tokenService;
        this._router = _router;
    }
    /**
     * @return {?}
     */
    LoggedInAuth.prototype.canActivate = function () {
        var /** @type {?} */ token = this._tokenService.getToken();
        if (token && token.token) {
            return !token.isExpired();
        }
        var /** @type {?} */ redirectUrl = this._config.guards.loggedInGuard.redirectUrl;
        if (redirectUrl) {
            this._router.navigate([redirectUrl]);
        }
        return false;
    };
    return LoggedInAuth;
}());
LoggedInAuth.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
LoggedInAuth.ctorParameters = function () { return [
    { type: AuthConfig, },
    { type: TokenService, },
    { type: Router, },
]; };

var AuthHttp = (function () {
    /**
     * @param {?} config
     * @param {?} _tokenService
     * @param {?} _http
     * @param {?} _options
     */
    function AuthHttp(config, _tokenService, _http, _options) {
        this.config = config;
        this._tokenService = _tokenService;
        this._http = _http;
        this._options = _options;
        this.config = new AuthConfig(config);
    }
    /**
     * @param {?} providedOpts
     * @param {?=} defaultOpts
     * @return {?}
     */
    AuthHttp.prototype.mergeOptions = function (providedOpts, defaultOpts) {
        var /** @type {?} */ newOptions = defaultOpts || new RequestOptions();
        if (this.config.globalHeaders) {
            this.setGlobalHeaders(this.config.globalHeaders, providedOpts);
        }
        newOptions = newOptions.merge(new RequestOptions(providedOpts));
        return newOptions;
    };
    /**
     * @param {?} requestArgs
     * @param {?=} additionalOptions
     * @return {?}
     */
    AuthHttp.prototype.requestHelper = function (requestArgs, additionalOptions) {
        var /** @type {?} */ options = new RequestOptions(requestArgs);
        if (additionalOptions) {
            options = options.merge(additionalOptions);
        }
        return this.request(new Request(this.mergeOptions(options, this._options)));
    };
    /**
     * @param {?} headers
     * @param {?} request
     * @return {?}
     */
    AuthHttp.prototype.setGlobalHeaders = function (headers, request) {
        if (!request.headers) {
            request.headers = new Headers();
        }
        headers.forEach(function (header) {
            var /** @type {?} */ key = Object.keys(header)[0];
            var /** @type {?} */ headerValue = ((header))[key];
            ((request.headers)).set(key, headerValue);
        });
    };
    /**
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    AuthHttp.prototype.request = function (url, options) {
        if (typeof url === 'string') {
            return this.get(url, options); // Recursion: transform url from String to Request
        }
        // from this point url is always an instance of Request;
        var /** @type {?} */ req = (url);
        var /** @type {?} */ token = this._tokenService.getToken();
        return this.requestWithToken(req, token);
    };
    /**
     * @param {?} req
     * @param {?} token
     * @return {?}
     */
    AuthHttp.prototype.requestWithToken = function (req, token) {
        if (token.isExpired()) {
            if (!this.config.noJwtError) {
                return new Observable(function (obs) {
                    obs.error(new Error('No JWT present or has expired'));
                });
            }
        }
        else {
            req.headers.set(this.config.headerName, this.config.headerPrefix + " " + token.token);
        }
        return this._http.request(req);
    };
    /**
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    AuthHttp.prototype.get = function (url, options) {
        return this.requestHelper({ body: '', method: RequestMethod.Get, url: url }, options);
    };
    /**
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    AuthHttp.prototype.post = function (url, body, options) {
        return this.requestHelper({ body: body, method: RequestMethod.Post, url: url }, options);
    };
    /**
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    AuthHttp.prototype.put = function (url, body, options) {
        return this.requestHelper({ body: body, method: RequestMethod.Put, url: url }, options);
    };
    /**
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    AuthHttp.prototype.delete = function (url, options) {
        return this.requestHelper({ body: '', method: RequestMethod.Delete, url: url }, options);
    };
    /**
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    AuthHttp.prototype.patch = function (url, body, options) {
        return this.requestHelper({ body: body, method: RequestMethod.Patch, url: url }, options);
    };
    /**
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    AuthHttp.prototype.head = function (url, options) {
        return this.requestHelper({ body: '', method: RequestMethod.Head, url: url }, options);
    };
    /**
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    AuthHttp.prototype.options = function (url, options) {
        return this.requestHelper({ body: '', method: RequestMethod.Options, url: url }, options);
    };
    return AuthHttp;
}());
AuthHttp.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
AuthHttp.ctorParameters = function () { return [
    { type: AuthConfig, },
    { type: TokenService, },
    { type: Http, },
    { type: RequestOptions, },
]; };

var NgJwtModule = (function () {
    function NgJwtModule() {
    }
    /**
     * @param {?=} config
     * @return {?}
     */
    NgJwtModule.forRoot = function (config) {
        return {
            ngModule: NgJwtModule,
            providers: [
                { provide: AuthConfig, useValue: config },
                Auth, TokenService, LoggedInAuth, LoggedOutAuth, AuthenticationService, AuthHttp,
                {
                    provide: HTTP_INTERCEPTORS,
                    useClass: JwtHttpInterceptor,
                    multi: true,
                },
            ]
        };
    };
    return NgJwtModule;
}());
NgJwtModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule, RouterModule, HttpModule
                ],
                declarations: [],
                exports: []
            },] },
];
/**
 * @nocollapse
 */
NgJwtModule.ctorParameters = function () { return []; };

export { NgJwtModule, LoggedOutAuth, LoggedInAuth, TokenService, AuthenticationService, Auth, JwtHttpInterceptor, AuthHttp, TokenError, Token, AuthConfig, AUTH_CONFIG_DEFAULTS };
